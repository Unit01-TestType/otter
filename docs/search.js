window.pdocSearch = (function(){
/** elasticlunr - http://weixsong.github.io * Copyright (C) 2017 Oliver Nightingale * Copyright (C) 2017 Wei Song * MIT Licensed */!function(){function e(e){if(null===e||"object"!=typeof e)return e;var t=e.constructor();for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n]);return t}var t=function(e){var n=new t.Index;return n.pipeline.add(t.trimmer,t.stopWordFilter,t.stemmer),e&&e.call(n,n),n};t.version="0.9.5",lunr=t,t.utils={},t.utils.warn=function(e){return function(t){e.console&&console.warn&&console.warn(t)}}(this),t.utils.toString=function(e){return void 0===e||null===e?"":e.toString()},t.EventEmitter=function(){this.events={}},t.EventEmitter.prototype.addListener=function(){var e=Array.prototype.slice.call(arguments),t=e.pop(),n=e;if("function"!=typeof t)throw new TypeError("last argument must be a function");n.forEach(function(e){this.hasHandler(e)||(this.events[e]=[]),this.events[e].push(t)},this)},t.EventEmitter.prototype.removeListener=function(e,t){if(this.hasHandler(e)){var n=this.events[e].indexOf(t);-1!==n&&(this.events[e].splice(n,1),0==this.events[e].length&&delete this.events[e])}},t.EventEmitter.prototype.emit=function(e){if(this.hasHandler(e)){var t=Array.prototype.slice.call(arguments,1);this.events[e].forEach(function(e){e.apply(void 0,t)},this)}},t.EventEmitter.prototype.hasHandler=function(e){return e in this.events},t.tokenizer=function(e){if(!arguments.length||null===e||void 0===e)return[];if(Array.isArray(e)){var n=e.filter(function(e){return null===e||void 0===e?!1:!0});n=n.map(function(e){return t.utils.toString(e).toLowerCase()});var i=[];return n.forEach(function(e){var n=e.split(t.tokenizer.seperator);i=i.concat(n)},this),i}return e.toString().trim().toLowerCase().split(t.tokenizer.seperator)},t.tokenizer.defaultSeperator=/[\s\-]+/,t.tokenizer.seperator=t.tokenizer.defaultSeperator,t.tokenizer.setSeperator=function(e){null!==e&&void 0!==e&&"object"==typeof e&&(t.tokenizer.seperator=e)},t.tokenizer.resetSeperator=function(){t.tokenizer.seperator=t.tokenizer.defaultSeperator},t.tokenizer.getSeperator=function(){return t.tokenizer.seperator},t.Pipeline=function(){this._queue=[]},t.Pipeline.registeredFunctions={},t.Pipeline.registerFunction=function(e,n){n in t.Pipeline.registeredFunctions&&t.utils.warn("Overwriting existing registered function: "+n),e.label=n,t.Pipeline.registeredFunctions[n]=e},t.Pipeline.getRegisteredFunction=function(e){return e in t.Pipeline.registeredFunctions!=!0?null:t.Pipeline.registeredFunctions[e]},t.Pipeline.warnIfFunctionNotRegistered=function(e){var n=e.label&&e.label in this.registeredFunctions;n||t.utils.warn("Function is not registered with pipeline. This may cause problems when serialising the index.\n",e)},t.Pipeline.load=function(e){var n=new t.Pipeline;return e.forEach(function(e){var i=t.Pipeline.getRegisteredFunction(e);if(!i)throw new Error("Cannot load un-registered function: "+e);n.add(i)}),n},t.Pipeline.prototype.add=function(){var e=Array.prototype.slice.call(arguments);e.forEach(function(e){t.Pipeline.warnIfFunctionNotRegistered(e),this._queue.push(e)},this)},t.Pipeline.prototype.after=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i+1,0,n)},t.Pipeline.prototype.before=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i,0,n)},t.Pipeline.prototype.remove=function(e){var t=this._queue.indexOf(e);-1!==t&&this._queue.splice(t,1)},t.Pipeline.prototype.run=function(e){for(var t=[],n=e.length,i=this._queue.length,o=0;n>o;o++){for(var r=e[o],s=0;i>s&&(r=this._queue[s](r,o,e),void 0!==r&&null!==r);s++);void 0!==r&&null!==r&&t.push(r)}return t},t.Pipeline.prototype.reset=function(){this._queue=[]},t.Pipeline.prototype.get=function(){return this._queue},t.Pipeline.prototype.toJSON=function(){return this._queue.map(function(e){return t.Pipeline.warnIfFunctionNotRegistered(e),e.label})},t.Index=function(){this._fields=[],this._ref="id",this.pipeline=new t.Pipeline,this.documentStore=new t.DocumentStore,this.index={},this.eventEmitter=new t.EventEmitter,this._idfCache={},this.on("add","remove","update",function(){this._idfCache={}}.bind(this))},t.Index.prototype.on=function(){var e=Array.prototype.slice.call(arguments);return this.eventEmitter.addListener.apply(this.eventEmitter,e)},t.Index.prototype.off=function(e,t){return this.eventEmitter.removeListener(e,t)},t.Index.load=function(e){e.version!==t.version&&t.utils.warn("version mismatch: current "+t.version+" importing "+e.version);var n=new this;n._fields=e.fields,n._ref=e.ref,n.documentStore=t.DocumentStore.load(e.documentStore),n.pipeline=t.Pipeline.load(e.pipeline),n.index={};for(var i in e.index)n.index[i]=t.InvertedIndex.load(e.index[i]);return n},t.Index.prototype.addField=function(e){return this._fields.push(e),this.index[e]=new t.InvertedIndex,this},t.Index.prototype.setRef=function(e){return this._ref=e,this},t.Index.prototype.saveDocument=function(e){return this.documentStore=new t.DocumentStore(e),this},t.Index.prototype.addDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.addDoc(i,e),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));this.documentStore.addFieldLength(i,n,o.length);var r={};o.forEach(function(e){e in r?r[e]+=1:r[e]=1},this);for(var s in r){var u=r[s];u=Math.sqrt(u),this.index[n].addToken(s,{ref:i,tf:u})}},this),n&&this.eventEmitter.emit("add",e,this)}},t.Index.prototype.removeDocByRef=function(e){if(e&&this.documentStore.isDocStored()!==!1&&this.documentStore.hasDoc(e)){var t=this.documentStore.getDoc(e);this.removeDoc(t,!1)}},t.Index.prototype.removeDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.hasDoc(i)&&(this.documentStore.removeDoc(i),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));o.forEach(function(e){this.index[n].removeToken(e,i)},this)},this),n&&this.eventEmitter.emit("remove",e,this))}},t.Index.prototype.updateDoc=function(e,t){var t=void 0===t?!0:t;this.removeDocByRef(e[this._ref],!1),this.addDoc(e,!1),t&&this.eventEmitter.emit("update",e,this)},t.Index.prototype.idf=function(e,t){var n="@"+t+"/"+e;if(Object.prototype.hasOwnProperty.call(this._idfCache,n))return this._idfCache[n];var i=this.index[t].getDocFreq(e),o=1+Math.log(this.documentStore.length/(i+1));return this._idfCache[n]=o,o},t.Index.prototype.getFields=function(){return this._fields.slice()},t.Index.prototype.search=function(e,n){if(!e)return[];e="string"==typeof e?{any:e}:JSON.parse(JSON.stringify(e));var i=null;null!=n&&(i=JSON.stringify(n));for(var o=new t.Configuration(i,this.getFields()).get(),r={},s=Object.keys(e),u=0;u<s.length;u++){var a=s[u];r[a]=this.pipeline.run(t.tokenizer(e[a]))}var l={};for(var c in o){var d=r[c]||r.any;if(d){var f=this.fieldSearch(d,c,o),h=o[c].boost;for(var p in f)f[p]=f[p]*h;for(var p in f)p in l?l[p]+=f[p]:l[p]=f[p]}}var v,g=[];for(var p in l)v={ref:p,score:l[p]},this.documentStore.hasDoc(p)&&(v.doc=this.documentStore.getDoc(p)),g.push(v);return g.sort(function(e,t){return t.score-e.score}),g},t.Index.prototype.fieldSearch=function(e,t,n){var i=n[t].bool,o=n[t].expand,r=n[t].boost,s=null,u={};return 0!==r?(e.forEach(function(e){var n=[e];1==o&&(n=this.index[t].expandToken(e));var r={};n.forEach(function(n){var o=this.index[t].getDocs(n),a=this.idf(n,t);if(s&&"AND"==i){var l={};for(var c in s)c in o&&(l[c]=o[c]);o=l}n==e&&this.fieldSearchStats(u,n,o);for(var c in o){var d=this.index[t].getTermFrequency(n,c),f=this.documentStore.getFieldLength(c,t),h=1;0!=f&&(h=1/Math.sqrt(f));var p=1;n!=e&&(p=.15*(1-(n.length-e.length)/n.length));var v=d*a*h*p;c in r?r[c]+=v:r[c]=v}},this),s=this.mergeScores(s,r,i)},this),s=this.coordNorm(s,u,e.length)):void 0},t.Index.prototype.mergeScores=function(e,t,n){if(!e)return t;if("AND"==n){var i={};for(var o in t)o in e&&(i[o]=e[o]+t[o]);return i}for(var o in t)o in e?e[o]+=t[o]:e[o]=t[o];return e},t.Index.prototype.fieldSearchStats=function(e,t,n){for(var i in n)i in e?e[i].push(t):e[i]=[t]},t.Index.prototype.coordNorm=function(e,t,n){for(var i in e)if(i in t){var o=t[i].length;e[i]=e[i]*o/n}return e},t.Index.prototype.toJSON=function(){var e={};return this._fields.forEach(function(t){e[t]=this.index[t].toJSON()},this),{version:t.version,fields:this._fields,ref:this._ref,documentStore:this.documentStore.toJSON(),index:e,pipeline:this.pipeline.toJSON()}},t.Index.prototype.use=function(e){var t=Array.prototype.slice.call(arguments,1);t.unshift(this),e.apply(this,t)},t.DocumentStore=function(e){this._save=null===e||void 0===e?!0:e,this.docs={},this.docInfo={},this.length=0},t.DocumentStore.load=function(e){var t=new this;return t.length=e.length,t.docs=e.docs,t.docInfo=e.docInfo,t._save=e.save,t},t.DocumentStore.prototype.isDocStored=function(){return this._save},t.DocumentStore.prototype.addDoc=function(t,n){this.hasDoc(t)||this.length++,this.docs[t]=this._save===!0?e(n):null},t.DocumentStore.prototype.getDoc=function(e){return this.hasDoc(e)===!1?null:this.docs[e]},t.DocumentStore.prototype.hasDoc=function(e){return e in this.docs},t.DocumentStore.prototype.removeDoc=function(e){this.hasDoc(e)&&(delete this.docs[e],delete this.docInfo[e],this.length--)},t.DocumentStore.prototype.addFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&(this.docInfo[e]||(this.docInfo[e]={}),this.docInfo[e][t]=n)},t.DocumentStore.prototype.updateFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&this.addFieldLength(e,t,n)},t.DocumentStore.prototype.getFieldLength=function(e,t){return null===e||void 0===e?0:e in this.docs&&t in this.docInfo[e]?this.docInfo[e][t]:0},t.DocumentStore.prototype.toJSON=function(){return{docs:this.docs,docInfo:this.docInfo,length:this.length,save:this._save}},t.stemmer=function(){var e={ational:"ate",tional:"tion",enci:"ence",anci:"ance",izer:"ize",bli:"ble",alli:"al",entli:"ent",eli:"e",ousli:"ous",ization:"ize",ation:"ate",ator:"ate",alism:"al",iveness:"ive",fulness:"ful",ousness:"ous",aliti:"al",iviti:"ive",biliti:"ble",logi:"log"},t={icate:"ic",ative:"",alize:"al",iciti:"ic",ical:"ic",ful:"",ness:""},n="[^aeiou]",i="[aeiouy]",o=n+"[^aeiouy]*",r=i+"[aeiou]*",s="^("+o+")?"+r+o,u="^("+o+")?"+r+o+"("+r+")?$",a="^("+o+")?"+r+o+r+o,l="^("+o+")?"+i,c=new RegExp(s),d=new RegExp(a),f=new RegExp(u),h=new RegExp(l),p=/^(.+?)(ss|i)es$/,v=/^(.+?)([^s])s$/,g=/^(.+?)eed$/,m=/^(.+?)(ed|ing)$/,y=/.$/,S=/(at|bl|iz)$/,x=new RegExp("([^aeiouylsz])\\1$"),w=new RegExp("^"+o+i+"[^aeiouwxy]$"),I=/^(.+?[^aeiou])y$/,b=/^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/,E=/^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/,D=/^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/,F=/^(.+?)(s|t)(ion)$/,_=/^(.+?)e$/,P=/ll$/,k=new RegExp("^"+o+i+"[^aeiouwxy]$"),z=function(n){var i,o,r,s,u,a,l;if(n.length<3)return n;if(r=n.substr(0,1),"y"==r&&(n=r.toUpperCase()+n.substr(1)),s=p,u=v,s.test(n)?n=n.replace(s,"$1$2"):u.test(n)&&(n=n.replace(u,"$1$2")),s=g,u=m,s.test(n)){var z=s.exec(n);s=c,s.test(z[1])&&(s=y,n=n.replace(s,""))}else if(u.test(n)){var z=u.exec(n);i=z[1],u=h,u.test(i)&&(n=i,u=S,a=x,l=w,u.test(n)?n+="e":a.test(n)?(s=y,n=n.replace(s,"")):l.test(n)&&(n+="e"))}if(s=I,s.test(n)){var z=s.exec(n);i=z[1],n=i+"i"}if(s=b,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+e[o])}if(s=E,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+t[o])}if(s=D,u=F,s.test(n)){var z=s.exec(n);i=z[1],s=d,s.test(i)&&(n=i)}else if(u.test(n)){var z=u.exec(n);i=z[1]+z[2],u=d,u.test(i)&&(n=i)}if(s=_,s.test(n)){var z=s.exec(n);i=z[1],s=d,u=f,a=k,(s.test(i)||u.test(i)&&!a.test(i))&&(n=i)}return s=P,u=d,s.test(n)&&u.test(n)&&(s=y,n=n.replace(s,"")),"y"==r&&(n=r.toLowerCase()+n.substr(1)),n};return z}(),t.Pipeline.registerFunction(t.stemmer,"stemmer"),t.stopWordFilter=function(e){return e&&t.stopWordFilter.stopWords[e]!==!0?e:void 0},t.clearStopWords=function(){t.stopWordFilter.stopWords={}},t.addStopWords=function(e){null!=e&&Array.isArray(e)!==!1&&e.forEach(function(e){t.stopWordFilter.stopWords[e]=!0},this)},t.resetStopWords=function(){t.stopWordFilter.stopWords=t.defaultStopWords},t.defaultStopWords={"":!0,a:!0,able:!0,about:!0,across:!0,after:!0,all:!0,almost:!0,also:!0,am:!0,among:!0,an:!0,and:!0,any:!0,are:!0,as:!0,at:!0,be:!0,because:!0,been:!0,but:!0,by:!0,can:!0,cannot:!0,could:!0,dear:!0,did:!0,"do":!0,does:!0,either:!0,"else":!0,ever:!0,every:!0,"for":!0,from:!0,get:!0,got:!0,had:!0,has:!0,have:!0,he:!0,her:!0,hers:!0,him:!0,his:!0,how:!0,however:!0,i:!0,"if":!0,"in":!0,into:!0,is:!0,it:!0,its:!0,just:!0,least:!0,let:!0,like:!0,likely:!0,may:!0,me:!0,might:!0,most:!0,must:!0,my:!0,neither:!0,no:!0,nor:!0,not:!0,of:!0,off:!0,often:!0,on:!0,only:!0,or:!0,other:!0,our:!0,own:!0,rather:!0,said:!0,say:!0,says:!0,she:!0,should:!0,since:!0,so:!0,some:!0,than:!0,that:!0,the:!0,their:!0,them:!0,then:!0,there:!0,these:!0,they:!0,"this":!0,tis:!0,to:!0,too:!0,twas:!0,us:!0,wants:!0,was:!0,we:!0,were:!0,what:!0,when:!0,where:!0,which:!0,"while":!0,who:!0,whom:!0,why:!0,will:!0,"with":!0,would:!0,yet:!0,you:!0,your:!0},t.stopWordFilter.stopWords=t.defaultStopWords,t.Pipeline.registerFunction(t.stopWordFilter,"stopWordFilter"),t.trimmer=function(e){if(null===e||void 0===e)throw new Error("token should not be undefined");return e.replace(/^\W+/,"").replace(/\W+$/,"")},t.Pipeline.registerFunction(t.trimmer,"trimmer"),t.InvertedIndex=function(){this.root={docs:{},df:0}},t.InvertedIndex.load=function(e){var t=new this;return t.root=e.root,t},t.InvertedIndex.prototype.addToken=function(e,t,n){for(var n=n||this.root,i=0;i<=e.length-1;){var o=e[i];o in n||(n[o]={docs:{},df:0}),i+=1,n=n[o]}var r=t.ref;n.docs[r]?n.docs[r]={tf:t.tf}:(n.docs[r]={tf:t.tf},n.df+=1)},t.InvertedIndex.prototype.hasToken=function(e){if(!e)return!1;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return!1;t=t[e[n]]}return!0},t.InvertedIndex.prototype.getNode=function(e){if(!e)return null;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return null;t=t[e[n]]}return t},t.InvertedIndex.prototype.getDocs=function(e){var t=this.getNode(e);return null==t?{}:t.docs},t.InvertedIndex.prototype.getTermFrequency=function(e,t){var n=this.getNode(e);return null==n?0:t in n.docs?n.docs[t].tf:0},t.InvertedIndex.prototype.getDocFreq=function(e){var t=this.getNode(e);return null==t?0:t.df},t.InvertedIndex.prototype.removeToken=function(e,t){if(e){var n=this.getNode(e);null!=n&&t in n.docs&&(delete n.docs[t],n.df-=1)}},t.InvertedIndex.prototype.expandToken=function(e,t,n){if(null==e||""==e)return[];var t=t||[];if(void 0==n&&(n=this.getNode(e),null==n))return t;n.df>0&&t.push(e);for(var i in n)"docs"!==i&&"df"!==i&&this.expandToken(e+i,t,n[i]);return t},t.InvertedIndex.prototype.toJSON=function(){return{root:this.root}},t.Configuration=function(e,n){var e=e||"";if(void 0==n||null==n)throw new Error("fields should not be null");this.config={};var i;try{i=JSON.parse(e),this.buildUserConfig(i,n)}catch(o){t.utils.warn("user configuration parse failed, will use default configuration"),this.buildDefaultConfig(n)}},t.Configuration.prototype.buildDefaultConfig=function(e){this.reset(),e.forEach(function(e){this.config[e]={boost:1,bool:"OR",expand:!1}},this)},t.Configuration.prototype.buildUserConfig=function(e,n){var i="OR",o=!1;if(this.reset(),"bool"in e&&(i=e.bool||i),"expand"in e&&(o=e.expand||o),"fields"in e)for(var r in e.fields)if(n.indexOf(r)>-1){var s=e.fields[r],u=o;void 0!=s.expand&&(u=s.expand),this.config[r]={boost:s.boost||0===s.boost?s.boost:1,bool:s.bool||i,expand:u}}else t.utils.warn("field name in user configuration not found in index instance fields");else this.addAllFields2UserConfig(i,o,n)},t.Configuration.prototype.addAllFields2UserConfig=function(e,t,n){n.forEach(function(n){this.config[n]={boost:1,bool:e,expand:t}},this)},t.Configuration.prototype.get=function(){return this.config},t.Configuration.prototype.reset=function(){this.config={}},lunr.SortedSet=function(){this.length=0,this.elements=[]},lunr.SortedSet.load=function(e){var t=new this;return t.elements=e,t.length=e.length,t},lunr.SortedSet.prototype.add=function(){var e,t;for(e=0;e<arguments.length;e++)t=arguments[e],~this.indexOf(t)||this.elements.splice(this.locationFor(t),0,t);this.length=this.elements.length},lunr.SortedSet.prototype.toArray=function(){return this.elements.slice()},lunr.SortedSet.prototype.map=function(e,t){return this.elements.map(e,t)},lunr.SortedSet.prototype.forEach=function(e,t){return this.elements.forEach(e,t)},lunr.SortedSet.prototype.indexOf=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;){if(r===e)return o;e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o]}return r===e?o:-1},lunr.SortedSet.prototype.locationFor=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;)e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o];return r>e?o:e>r?o+1:void 0},lunr.SortedSet.prototype.intersect=function(e){for(var t=new lunr.SortedSet,n=0,i=0,o=this.length,r=e.length,s=this.elements,u=e.elements;;){if(n>o-1||i>r-1)break;s[n]!==u[i]?s[n]<u[i]?n++:s[n]>u[i]&&i++:(t.add(s[n]),n++,i++)}return t},lunr.SortedSet.prototype.clone=function(){var e=new lunr.SortedSet;return e.elements=this.toArray(),e.length=e.elements.length,e},lunr.SortedSet.prototype.union=function(e){var t,n,i;this.length>=e.length?(t=this,n=e):(t=e,n=this),i=t.clone();for(var o=0,r=n.toArray();o<r.length;o++)i.add(r[o]);return i},lunr.SortedSet.prototype.toJSON=function(){return this.toArray()},function(e,t){"function"==typeof define&&define.amd?define(t):"object"==typeof exports?module.exports=t():e.elasticlunr=t()}(this,function(){return t})}();
    /** pdoc search index */const docs = [{"fullname": "otter", "modulename": "otter", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "otter.bother_utils", "modulename": "otter.bother_utils", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "otter.bother_utils.heightmap", "modulename": "otter.bother_utils.heightmap", "kind": "module", "doc": "<p>Functions to manipulate TIF files and convert them into heightmaps.</p>\n"}, {"fullname": "otter.bother_utils.heightmap.WGS84", "modulename": "otter.bother_utils.heightmap", "qualname": "WGS84", "kind": "variable", "doc": "<p></p>\n", "default_value": "&#x27;EPSG:4326&#x27;"}, {"fullname": "otter.bother_utils.heightmap.remove_sea", "modulename": "otter.bother_utils.heightmap", "qualname": "remove_sea", "kind": "function", "doc": "<p>Offset elevation data so that lowest value is equal to min_elev.\nUseful for when real-world data includes land below sea level but no\nsea (eg, an in-land NL map).</p>\n\n<p>By default,min_elev is 1, which means you may need to use this in\nconjunction with raise_low_pixels to actually render as land.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">memfile</span><span class=\"p\">:</span> <span class=\"n\">rasterio</span><span class=\"o\">.</span><span class=\"n\">io</span><span class=\"o\">.</span><span class=\"n\">MemoryFile</span>,</span><span class=\"param\">\t<span class=\"n\">min_elev</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">1</span></span><span class=\"return-annotation\">) -> <span class=\"n\">rasterio</span><span class=\"o\">.</span><span class=\"n\">io</span><span class=\"o\">.</span><span class=\"n\">MemoryFile</span>:</span></span>", "funcdef": "def"}, {"fullname": "otter.bother_utils.heightmap.resample", "modulename": "otter.bother_utils.heightmap", "qualname": "resample", "kind": "function", "doc": "<p>Resample raster by a factor of scale_factor.\nscale_factor &gt; 1:  Upsample\nscale factor &lt; 1:  Downsample</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">memfile</span><span class=\"p\">:</span> <span class=\"n\">rasterio</span><span class=\"o\">.</span><span class=\"n\">io</span><span class=\"o\">.</span><span class=\"n\">MemoryFile</span>,</span><span class=\"param\">\t<span class=\"n\">scale_factor</span><span class=\"p\">:</span> <span class=\"nb\">float</span></span><span class=\"return-annotation\">) -> <span class=\"n\">rasterio</span><span class=\"o\">.</span><span class=\"n\">io</span><span class=\"o\">.</span><span class=\"n\">MemoryFile</span>:</span></span>", "funcdef": "def"}, {"fullname": "otter.bother_utils.heightmap.reproject_raster", "modulename": "otter.bother_utils.heightmap", "qualname": "reproject_raster", "kind": "function", "doc": "<p>Reproject raster with CRS src_crs to new CRS dst_crs.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">memfile</span><span class=\"p\">:</span> <span class=\"n\">rasterio</span><span class=\"o\">.</span><span class=\"n\">io</span><span class=\"o\">.</span><span class=\"n\">MemoryFile</span>,</span><span class=\"param\">\t<span class=\"n\">dst_crs</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">src_crs</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;EPSG:4326&#39;</span></span><span class=\"return-annotation\">) -> <span class=\"n\">rasterio</span><span class=\"o\">.</span><span class=\"n\">io</span><span class=\"o\">.</span><span class=\"n\">MemoryFile</span>:</span></span>", "funcdef": "def"}, {"fullname": "otter.bother_utils.heightmap.get_lake", "modulename": "otter.bother_utils.heightmap", "qualname": "get_lake", "kind": "function", "doc": "<p>Check if the pixel at data[row, col] belongs to a lake and, if so,\nreturn the lake as a set of points.</p>\n\n<p>We use a flood fill algorithm to detect contiguous sets of pixels\nthat have exactly identical elevation.  This is similar to the\nalgorithm (apparently) used by the MicroDEM software: see\n<a href=\"https://freegeographytools.com/2007/modifying-the-terrain-reflectance-display-in-microdem\">https://freegeographytools.com/2007/modifying-the-terrain-reflectance-display-in-microdem</a></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">data</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">row</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">col</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">checked</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">min_size</span><span class=\"p\">:</span> <span class=\"nb\">int</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">Set</span><span class=\"p\">[</span><span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]]]</span>:</span></span>", "funcdef": "def"}, {"fullname": "otter.bother_utils.heightmap.get_all_lakes", "modulename": "otter.bother_utils.heightmap", "qualname": "get_all_lakes", "kind": "function", "doc": "<p>Find all lakes in the data.  A lake is defined as a contiguous\nregion of at least min_size pixels of the exact same elevation.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">data</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">min_size</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">nodata</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"o\">-</span><span class=\"mi\">32768</span></span><span class=\"return-annotation\">) -> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">Set</span><span class=\"p\">[</span><span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]]]</span>:</span></span>", "funcdef": "def"}, {"fullname": "otter.bother_utils.heightmap.set_lakes_to_elev", "modulename": "otter.bother_utils.heightmap", "qualname": "set_lakes_to_elev", "kind": "function", "doc": "<p>Find all lakes in the data for a raster and set the elevation of\nthe relevant pixels to fill_lakes_as.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">memfile</span><span class=\"p\">:</span> <span class=\"n\">rasterio</span><span class=\"o\">.</span><span class=\"n\">io</span><span class=\"o\">.</span><span class=\"n\">MemoryFile</span>,</span><span class=\"param\">\t<span class=\"n\">min_lake_size</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">fill_lakes_as</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">nodata</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"o\">-</span><span class=\"mi\">32768</span></span><span class=\"return-annotation\">) -> <span class=\"n\">rasterio</span><span class=\"o\">.</span><span class=\"n\">io</span><span class=\"o\">.</span><span class=\"n\">MemoryFile</span>:</span></span>", "funcdef": "def"}, {"fullname": "otter.bother_utils.heightmap.raise_undersea_land", "modulename": "otter.bother_utils.heightmap", "qualname": "raise_undersea_land", "kind": "function", "doc": "<p>Raise land with zero or negative elevation (ie, land that is at or\nbelow sea level) to raise_to. Probably shouldn't be called before\nset_lakes_to_elev, otherwise the newly raised land will be picked up\nas a lake by that function.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">memfile</span><span class=\"p\">:</span> <span class=\"n\">rasterio</span><span class=\"o\">.</span><span class=\"n\">io</span><span class=\"o\">.</span><span class=\"n\">MemoryFile</span>,</span><span class=\"param\">\t<span class=\"n\">raise_to</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">1</span>,</span><span class=\"param\">\t<span class=\"n\">nodata</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"o\">-</span><span class=\"mi\">32768</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "otter.bother_utils.heightmap.raise_low_pixels", "modulename": "otter.bother_utils.heightmap", "qualname": "raise_low_pixels", "kind": "function", "doc": "<p>Detect very low (but above sea level) elevations in a raster and\nincrease the elevation of the relevant pixels such that, when the\nfile is converted to a greyscale image, those pixels will be given\na value of 1, rather than rounded down to 0.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">memfile</span><span class=\"p\">:</span> <span class=\"n\">rasterio</span><span class=\"o\">.</span><span class=\"n\">io</span><span class=\"o\">.</span><span class=\"n\">MemoryFile</span>,</span><span class=\"param\">\t<span class=\"n\">max_no_raise</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.0</span>,</span><span class=\"param\">\t<span class=\"n\">max_brightness</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">255</span>,</span><span class=\"param\">\t<span class=\"n\">noisy</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span></span><span class=\"return-annotation\">) -> <span class=\"n\">rasterio</span><span class=\"o\">.</span><span class=\"n\">io</span><span class=\"o\">.</span><span class=\"n\">MemoryFile</span>:</span></span>", "funcdef": "def"}, {"fullname": "otter.bother_utils.heightmap.to_png", "modulename": "otter.bother_utils.heightmap", "qualname": "to_png", "kind": "function", "doc": "<p>Save raster as a greyscale PNG file to to_file.  If set_negative\nis set, any elevation values below zero are set to that value (which\nshould be in the range 0-255).</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">memfile</span><span class=\"p\">:</span> <span class=\"n\">rasterio</span><span class=\"o\">.</span><span class=\"n\">io</span><span class=\"o\">.</span><span class=\"n\">MemoryFile</span>,</span><span class=\"param\">\t<span class=\"n\">zero_floor</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">max_brightness</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">255</span>,</span><span class=\"param\">\t<span class=\"n\">nodata</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"o\">-</span><span class=\"mi\">32768</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "otter.bother_utils.heightmap.crop_modes", "modulename": "otter.bother_utils.heightmap", "qualname": "crop_modes", "kind": "variable", "doc": "<p></p>\n", "default_value": "{&#x27;n&#x27;, &#x27;w&#x27;, &#x27;se&#x27;, &#x27;s&#x27;, &#x27;sw&#x27;, &#x27;nw&#x27;, &#x27;ne&#x27;, &#x27;c&#x27;, &#x27;e&#x27;}"}, {"fullname": "otter.bother_utils.heightmap.crop_image", "modulename": "otter.bother_utils.heightmap", "qualname": "crop_image", "kind": "function", "doc": "<p>Crop an image to width x height. Where in the image to crop to is\ndetermined by mode.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">im</span><span class=\"p\">:</span> <span class=\"o\">&lt;</span><span class=\"n\">module</span> <span class=\"s1\">&#39;PIL.Image&#39;</span> <span class=\"kn\">from</span> <span class=\"s1\">&#39;C:</span><span class=\"se\">\\\\</span><span class=\"s1\">Users</span><span class=\"se\">\\\\</span><span class=\"s1\">Marc</span><span class=\"se\">\\\\</span><span class=\"s1\">anaconda3</span><span class=\"se\">\\\\</span><span class=\"s1\">envs</span><span class=\"se\">\\\\</span><span class=\"s1\">geoenv310</span><span class=\"se\">\\\\</span><span class=\"s1\">lib</span><span class=\"se\">\\\\</span><span class=\"s1\">site-packages</span><span class=\"se\">\\\\</span><span class=\"s1\">PIL</span><span class=\"se\">\\\\</span><span class=\"s1\">Image.py&#39;</span><span class=\"o\">&gt;</span>,</span><span class=\"param\">\t<span class=\"n\">width</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">height</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">mode</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"o\">&lt;</span><span class=\"n\">module</span> <span class=\"s1\">&#39;PIL.Image&#39;</span> <span class=\"kn\">from</span> <span class=\"s1\">&#39;C:</span><span class=\"se\">\\\\</span><span class=\"s1\">Users</span><span class=\"se\">\\\\</span><span class=\"s1\">Marc</span><span class=\"se\">\\\\</span><span class=\"s1\">anaconda3</span><span class=\"se\">\\\\</span><span class=\"s1\">envs</span><span class=\"se\">\\\\</span><span class=\"s1\">geoenv310</span><span class=\"se\">\\\\</span><span class=\"s1\">lib</span><span class=\"se\">\\\\</span><span class=\"s1\">site-packages</span><span class=\"se\">\\\\</span><span class=\"s1\">PIL</span><span class=\"se\">\\\\</span><span class=\"s1\">Image.py&#39;</span><span class=\"o\">&gt;</span>:</span></span>", "funcdef": "def"}, {"fullname": "otter.bother_utils.heightmap.scale_image_f", "modulename": "otter.bother_utils.heightmap", "qualname": "scale_image_f", "kind": "function", "doc": "<p>Scale an image to width x height.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">im</span><span class=\"p\">:</span> <span class=\"o\">&lt;</span><span class=\"n\">module</span> <span class=\"s1\">&#39;PIL.Image&#39;</span> <span class=\"kn\">from</span> <span class=\"s1\">&#39;C:</span><span class=\"se\">\\\\</span><span class=\"s1\">Users</span><span class=\"se\">\\\\</span><span class=\"s1\">Marc</span><span class=\"se\">\\\\</span><span class=\"s1\">anaconda3</span><span class=\"se\">\\\\</span><span class=\"s1\">envs</span><span class=\"se\">\\\\</span><span class=\"s1\">geoenv310</span><span class=\"se\">\\\\</span><span class=\"s1\">lib</span><span class=\"se\">\\\\</span><span class=\"s1\">site-packages</span><span class=\"se\">\\\\</span><span class=\"s1\">PIL</span><span class=\"se\">\\\\</span><span class=\"s1\">Image.py&#39;</span><span class=\"o\">&gt;</span>,</span><span class=\"param\">\t<span class=\"n\">width</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">height</span><span class=\"p\">:</span> <span class=\"nb\">int</span></span><span class=\"return-annotation\">) -> <span class=\"o\">&lt;</span><span class=\"n\">module</span> <span class=\"s1\">&#39;PIL.Image&#39;</span> <span class=\"kn\">from</span> <span class=\"s1\">&#39;C:</span><span class=\"se\">\\\\</span><span class=\"s1\">Users</span><span class=\"se\">\\\\</span><span class=\"s1\">Marc</span><span class=\"se\">\\\\</span><span class=\"s1\">anaconda3</span><span class=\"se\">\\\\</span><span class=\"s1\">envs</span><span class=\"se\">\\\\</span><span class=\"s1\">geoenv310</span><span class=\"se\">\\\\</span><span class=\"s1\">lib</span><span class=\"se\">\\\\</span><span class=\"s1\">site-packages</span><span class=\"se\">\\\\</span><span class=\"s1\">PIL</span><span class=\"se\">\\\\</span><span class=\"s1\">Image.py&#39;</span><span class=\"o\">&gt;</span>:</span></span>", "funcdef": "def"}, {"fullname": "otter.bother_utils.heightmap.png_to_file", "modulename": "otter.bother_utils.heightmap", "qualname": "png_to_file", "kind": "function", "doc": "<p>Save image to file.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">im</span><span class=\"p\">:</span> <span class=\"o\">&lt;</span><span class=\"n\">module</span> <span class=\"s1\">&#39;PIL.Image&#39;</span> <span class=\"kn\">from</span> <span class=\"s1\">&#39;C:</span><span class=\"se\">\\\\</span><span class=\"s1\">Users</span><span class=\"se\">\\\\</span><span class=\"s1\">Marc</span><span class=\"se\">\\\\</span><span class=\"s1\">anaconda3</span><span class=\"se\">\\\\</span><span class=\"s1\">envs</span><span class=\"se\">\\\\</span><span class=\"s1\">geoenv310</span><span class=\"se\">\\\\</span><span class=\"s1\">lib</span><span class=\"se\">\\\\</span><span class=\"s1\">site-packages</span><span class=\"se\">\\\\</span><span class=\"s1\">PIL</span><span class=\"se\">\\\\</span><span class=\"s1\">Image.py&#39;</span><span class=\"o\">&gt;</span>,</span><span class=\"param\">\t<span class=\"n\">to_file</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "otter.bother_utils.srtm", "modulename": "otter.bother_utils.srtm", "kind": "module", "doc": "<p>Functions to download SRTM data from CGIAR website and generate a\nTIF file for the desired coordinates using that data.</p>\n"}, {"fullname": "otter.bother_utils.srtm.ZIP_BASE_URL", "modulename": "otter.bother_utils.srtm", "qualname": "ZIP_BASE_URL", "kind": "variable", "doc": "<p></p>\n", "default_value": "&#x27;http://srtm.csi.cgiar.org/wp-content/uploads/files/srtm_5x5/TIFF/&#x27;"}, {"fullname": "otter.bother_utils.srtm.ZIP_FNAME", "modulename": "otter.bother_utils.srtm", "qualname": "ZIP_FNAME", "kind": "variable", "doc": "<p></p>\n", "default_value": "&#x27;srtm_{x:02d}_{y:02d}.zip&#x27;"}, {"fullname": "otter.bother_utils.srtm.TIF_FNAME", "modulename": "otter.bother_utils.srtm", "qualname": "TIF_FNAME", "kind": "variable", "doc": "<p></p>\n", "default_value": "&#x27;srtm_{x:02d}_{y:02d}.tif&#x27;"}, {"fullname": "otter.bother_utils.srtm.TILE_X_BOUNDS", "modulename": "otter.bother_utils.srtm", "qualname": "TILE_X_BOUNDS", "kind": "variable", "doc": "<p></p>\n", "default_value": "(1, 72)"}, {"fullname": "otter.bother_utils.srtm.TILE_Y_BOUNDS", "modulename": "otter.bother_utils.srtm", "qualname": "TILE_Y_BOUNDS", "kind": "variable", "doc": "<p></p>\n", "default_value": "(1, 24)"}, {"fullname": "otter.bother_utils.srtm.TILE_SHAPE", "modulename": "otter.bother_utils.srtm", "qualname": "TILE_SHAPE", "kind": "variable", "doc": "<p></p>\n", "default_value": "(6000, 6000)"}, {"fullname": "otter.bother_utils.srtm.SRTM_NODATA", "modulename": "otter.bother_utils.srtm", "qualname": "SRTM_NODATA", "kind": "variable", "doc": "<p></p>\n", "default_value": "-32768"}, {"fullname": "otter.bother_utils.srtm.CACHE_DIR", "modulename": "otter.bother_utils.srtm", "qualname": "CACHE_DIR", "kind": "variable", "doc": "<p></p>\n", "default_value": "&#x27;C:\\\\Users\\\\Marc\\\\AppData\\\\Local\\\\bother\\\\Cache&#x27;"}, {"fullname": "otter.bother_utils.srtm.wrap_range", "modulename": "otter.bother_utils.srtm", "qualname": "wrap_range", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">start</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">end</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">min_val</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">1</span>,</span><span class=\"param\">\t<span class=\"n\">max_val</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">72</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Iterable</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "otter.bother_utils.srtm.is_cached", "modulename": "otter.bother_utils.srtm", "qualname": "is_cached", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">fname</span><span class=\"p\">:</span> <span class=\"nb\">str</span>, </span><span class=\"param\"><span class=\"n\">cache_dir</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "otter.bother_utils.srtm.get_cached_files", "modulename": "otter.bother_utils.srtm", "qualname": "get_cached_files", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">cache_dir</span><span class=\"p\">:</span> <span class=\"nb\">str</span>, </span><span class=\"param\"><span class=\"n\">ext</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;&#39;</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Iterable</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "otter.bother_utils.srtm.get_extract_dir", "modulename": "otter.bother_utils.srtm", "qualname": "get_extract_dir", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">cache_dir</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">str</span>:</span></span>", "funcdef": "def"}, {"fullname": "otter.bother_utils.srtm.get_tif_fpath", "modulename": "otter.bother_utils.srtm", "qualname": "get_tif_fpath", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">x</span><span class=\"p\">:</span> <span class=\"nb\">int</span>, </span><span class=\"param\"><span class=\"n\">y</span><span class=\"p\">:</span> <span class=\"nb\">int</span>, </span><span class=\"param\"><span class=\"n\">cache_dir</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">str</span>:</span></span>", "funcdef": "def"}, {"fullname": "otter.bother_utils.srtm.download_zip", "modulename": "otter.bother_utils.srtm", "qualname": "download_zip", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">url</span><span class=\"p\">:</span> <span class=\"nb\">str</span>, </span><span class=\"param\"><span class=\"n\">save_path</span><span class=\"p\">:</span> <span class=\"nb\">str</span>, </span><span class=\"param\"><span class=\"n\">chunk_size</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">1024</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "otter.bother_utils.srtm.get_xy_components", "modulename": "otter.bother_utils.srtm", "qualname": "get_xy_components", "kind": "function", "doc": "<p>For a given longitude and latitude, returns the relevant\ncomponents of the name of the zip file containing the SRTM data (for\nexample \"35\" and \"02\" in \"srtm_35_02.zip\").</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">lon</span><span class=\"p\">:</span> <span class=\"nb\">float</span>, </span><span class=\"param\"><span class=\"n\">lat</span><span class=\"p\">:</span> <span class=\"nb\">float</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "otter.bother_utils.srtm.get_all_xy_components", "modulename": "otter.bother_utils.srtm", "qualname": "get_all_xy_components", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">left</span><span class=\"p\">:</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">bottom</span><span class=\"p\">:</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">right</span><span class=\"p\">:</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">top</span><span class=\"p\">:</span> <span class=\"nb\">float</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Iterable</span><span class=\"p\">[</span><span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]]</span>:</span></span>", "funcdef": "def"}, {"fullname": "otter.bother_utils.srtm.get_all_zip_fnames", "modulename": "otter.bother_utils.srtm", "qualname": "get_all_zip_fnames", "kind": "function", "doc": "<p>Get zip file URLs for all tiles relevant to the area within the\ngiven bounds.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">left</span><span class=\"p\">:</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">bottom</span><span class=\"p\">:</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">right</span><span class=\"p\">:</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">top</span><span class=\"p\">:</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">cache_dir</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Dict</span><span class=\"p\">[</span><span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">],</span> <span class=\"nb\">str</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "otter.bother_utils.srtm.fetch_all_zips", "modulename": "otter.bother_utils.srtm", "qualname": "fetch_all_zips", "kind": "function", "doc": "<p>Takes a dict mapping xy pairs to zip filenames, downloads the\nrelevant files if they are not already in the cache, and returns\na dict mapping each xy pair to the absolute paths of the relevant\nzip file.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">fnames</span><span class=\"p\">:</span> <span class=\"n\">Dict</span><span class=\"p\">[</span><span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">],</span> <span class=\"nb\">str</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">cache_dir</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Dict</span><span class=\"p\">[</span><span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">],</span> <span class=\"nb\">str</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "otter.bother_utils.srtm.unzip_all", "modulename": "otter.bother_utils.srtm", "qualname": "unzip_all", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">zip_files</span><span class=\"p\">:</span> <span class=\"n\">Iterable</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]</span>, </span><span class=\"param\"><span class=\"n\">cache_dir</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">str</span>:</span></span>", "funcdef": "def"}, {"fullname": "otter.bother_utils.srtm.create_tif_file", "modulename": "otter.bother_utils.srtm", "qualname": "create_tif_file", "kind": "function", "doc": "<p>Create a TIF file using SRTM data  for the box defined by left,\nbottom, right, top.  If to_file is provided, saves the resulting\nfile to to_file and returns the path; otherwise, creates a\nrasterio.io.MemoryFile and returns that.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">left</span><span class=\"p\">:</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">bottom</span><span class=\"p\">:</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">right</span><span class=\"p\">:</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">top</span><span class=\"p\">:</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">to_file</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">cache_dir</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;C:</span><span class=\"se\">\\\\</span><span class=\"s1\">Users</span><span class=\"se\">\\\\</span><span class=\"s1\">Marc</span><span class=\"se\">\\\\</span><span class=\"s1\">AppData</span><span class=\"se\">\\\\</span><span class=\"s1\">Local</span><span class=\"se\">\\\\</span><span class=\"s1\">bother</span><span class=\"se\">\\\\</span><span class=\"s1\">Cache&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">nodata</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"o\">-</span><span class=\"mi\">32768</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">rasterio</span><span class=\"o\">.</span><span class=\"n\">io</span><span class=\"o\">.</span><span class=\"n\">MemoryFile</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "otter.bother_utils.srtm.clear_cache", "modulename": "otter.bother_utils.srtm", "qualname": "clear_cache", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">cache_dir</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;C:</span><span class=\"se\">\\\\</span><span class=\"s1\">Users</span><span class=\"se\">\\\\</span><span class=\"s1\">Marc</span><span class=\"se\">\\\\</span><span class=\"s1\">AppData</span><span class=\"se\">\\\\</span><span class=\"s1\">Local</span><span class=\"se\">\\\\</span><span class=\"s1\">bother</span><span class=\"se\">\\\\</span><span class=\"s1\">Cache&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">extracted_only</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "otter.otter", "modulename": "otter.otter", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "otter.otter.add_land", "modulename": "otter.otter.add_land", "kind": "module", "doc": "<p>This script contains a function to edit the game map (in raster form) to convert water to land.</p>\n\n<p>This is an advanced feature requring basic GIS knowledge.</p>\n"}, {"fullname": "otter.otter.add_land.add_land", "modulename": "otter.otter.add_land", "qualname": "add_land", "kind": "function", "doc": "<p>This function edits a raster by setting land to water.</p>\n\n<p>Parameters</p>\n\n<hr />\n\n<p><strong>ras</strong> : <em>str, path</em>;\n     path to a raster file from georeferenced png output from bother OR an original data raster.</p>\n\n<p><strong>shp_path</strong> : <em>str, path</em>;\n     path to a shapefile containing polygons for areas to convert to land.</p>\n\n<p><strong>outpath</strong> : <em>str, path</em>;\n     path to write a new tif.</p>\n\n<p><strong>elevation</strong> : <em>int, float</em>;\n     1-255 for grayscale to edit scaled outputs from bother; if editting data rasters, rerun through bother to convert to grayscale</p>\n\n<p><strong>select_col</strong> : <em>str</em>;\n     column name to filter values</p>\n\n<p><strong>select_val</strong> : <em>str, int, float</em>;\n     value used to fitler values in select_col</p>\n\n<p>Returns</p>\n\n<hr />\n\n<p>Writes GeoTIFF.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">ras</span>,</span><span class=\"param\">\t<span class=\"n\">shp_path</span>,</span><span class=\"param\">\t<span class=\"n\">outpath</span>,</span><span class=\"param\">\t<span class=\"n\">elevation</span><span class=\"o\">=</span><span class=\"mi\">1</span>,</span><span class=\"param\">\t<span class=\"n\">select_col</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">select_val</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "otter.otter.add_water", "modulename": "otter.otter.add_water", "kind": "module", "doc": "<p>This script contains a function to edit the game map (in raster form) to\nset rivers and lakes to sea level.\nThis is designed for water features that are near sea-level and would not create\nstrange adjacent terrain. </p>\n\n<p>This is an advanced feature requring basic GIS knowledge.</p>\n"}, {"fullname": "otter.otter.add_water.add_water", "modulename": "otter.otter.add_water", "qualname": "add_water", "kind": "function", "doc": "<p>This function edits a raster by setting rivers and lakes to sea-level.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p><strong>ras</strong> : <em>str, path</em>;\n    path to a raster file from georeferenced png output from bother.</p>\n\n<p><strong>shp_path</strong> : <em>str, path</em>;\n    path to a shapefile containing river delineations or lake polygons.</p>\n\n<p><strong>outpath</strong> : <em>str, path</em>;\n    path to write a new tif.</p>\n\n<p><strong>select_col</strong> : <em>str</em>;\n    column name to filter values</p>\n\n<p><strong>select_val</strong> : <em>str, int, float</em>;\n    value used to fitler values in select_col</p>\n\n<p><strong>buffer</strong> : <em>int</em>;\n    If provided, creates a buffer around the inputs shapes of the indicated number of tiles.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>None.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">ras</span>,</span><span class=\"param\">\t<span class=\"n\">shp_path</span>,</span><span class=\"param\">\t<span class=\"n\">outpath</span>,</span><span class=\"param\">\t<span class=\"n\">select_col</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">select_val</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">buffer</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "otter.otter.bother", "modulename": "otter.otter.bother", "kind": "module", "doc": "<p>This script contains an adaptation of bother by bunburya for to work with otter to retrieve terrain data\nand create a png and tif raster for the heightmap.</p>\n\n<p>bother: <a href=\"https://github.com/bunburya/bother/tree/master\">https://github.com/bunburya/bother/tree/master</a></p>\n\n<p>TODO:\n    - allow bounds to be read from shapefile directly</p>\n"}, {"fullname": "otter.otter.bother.WGS84", "modulename": "otter.otter.bother", "qualname": "WGS84", "kind": "variable", "doc": "<p></p>\n", "default_value": "4326"}, {"fullname": "otter.otter.bother.PSEUDO_MERCATOR", "modulename": "otter.otter.bother", "qualname": "PSEUDO_MERCATOR", "kind": "variable", "doc": "<p></p>\n", "default_value": "3857"}, {"fullname": "otter.otter.bother.error", "modulename": "otter.otter.bother", "qualname": "error", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">msg</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "otter.otter.bother.bother", "modulename": "otter.otter.bother", "qualname": "bother", "kind": "function", "doc": "<p>Run bother to download SRTM elevation data.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p><strong>bounds</strong> : <em>list</em>;\n    Bounding box; bottom left and top right in lat long.</p>\n\n<p><strong>outfile</strong> : <em>str, path</em>;\n    The file to which the greyscale PNG image will be written.</p>\n\n<p><strong>outfile_tif</strong> : <em>str, path</em>\n    Path to output tif file.</p>\n\n<p><strong>infile_tif</strong> : <em>str, path, optional</em>;\n    Path to a tif file containing elevation data. The default is None.</p>\n\n<p><strong>scale_data</strong> : <em>float, optional</em>;\n    more than 1 will upsample the data resolution; less than 1 downsample the data resolution. The default is None.</p>\n\n<p><strong>epsg</strong> : <em>int, optional</em>;\n    Coordinate Reference System EPSG code to project data. The default is '4326'.</p>\n\n<p><strong>raise_low</strong> : <em>float, optional</em>;\n    Values below the input will be rounded down to 0. The default is 0.</p>\n\n<p><strong>raise_undersea</strong> : <em>int, optional</em>;\n    Raise pixels with an elevation below zero (ie, land that is below sea-level) to the given level. The default is None.</p>\n\n<p><strong>no_sea</strong> : <em>float, optional</em>;\n    Raise pixels with low elevation so that they have a non-zero value in the resulting greyscale image. Only values with elevations above the above that value will be raised.</p>\n\n<p><strong>lakes</strong> : <em>int, optional</em>;\n    Detect lakes and set to 0; provided value is the minimum number of contiguous pixels needed. The default is None.</p>\n\n<p><strong>max_brightness</strong> : <em>int, optional</em>;\n    Set the highest point of the elevation to the provided value rather than 255. The default is None.</p>\n\n<p><strong>infile_png</strong> : <em>str, path, optional</em>;\n    Path to output png file. The default is None.</p>\n\n<p><strong>crop</strong> : <em>str, optional</em>;\n    Crop the resulting image to WIDTH x HEIGHT. MODE determines which region of the image to crop to and must be one of nw, n, ne, e, c, w, sw, s, se. The default is None.</p>\n\n<p><strong>scale_image</strong> : <em>str, optional</em>;\n    Scale the resulting image to WIDTH x HEIGHT. The default is None.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>Writes GeoTIFF and/or PNG.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">outfile</span>,</span><span class=\"param\">\t<span class=\"n\">bounds</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">outfile_tif</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">infile_tif</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">scale_data</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">epsg</span><span class=\"o\">=</span><span class=\"s1\">&#39;4326&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">raise_low</span><span class=\"o\">=</span><span class=\"mi\">0</span>,</span><span class=\"param\">\t<span class=\"n\">raise_undersea</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">no_sea</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">lakes</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">max_brightness</span><span class=\"o\">=</span><span class=\"mi\">255</span>,</span><span class=\"param\">\t<span class=\"n\">infile_png</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">crop</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">scale_image</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "otter.otter.build_info", "modulename": "otter.otter.build_info", "kind": "module", "doc": "<p>This script contains the functions needed to build info.nut for the custom map gamescript\nThis is based on boiler plate provided by MinimalGS from Leif Linse.</p>\n"}, {"fullname": "otter.otter.build_info.build_info", "modulename": "otter.otter.build_info", "qualname": "build_info", "kind": "function", "doc": "<p>This function creates info.nut for a custom map gamescript</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p><strong>outdir</strong> : <em>str, path</em>;\n    Output directory to write the info.nut file.</p>\n\n<p><strong>author</strong> : <em>str</em>;\n    Author of the gamescript.</p>\n\n<p><strong>name</strong> : <em>str</em>;\n    Name of the gamescript.</p>\n\n<p><strong>short_name</strong> : <em>str</em>;\n    Short name of the gamescript, must be four letters.</p>\n\n<p><strong>description</strong> : <em>str</em>;\n    Brief description of the gamescript.</p>\n\n<p><strong>version</strong> : <em>str, optional</em>;\n    The gamescript version. The default is 'SELF_VERSION' to get from version.nut.</p>\n\n<p><strong>date</strong> : <em>str, optional</em>;\n    The date of the gamescript version. The default is ''.</p>\n\n<p><strong>API_version</strong> : <em>str, optional</em>;\n    The API version to use for the gamescript. The default is '14'.</p>\n\n<p><strong>url</strong> : <em>str, optional</em>;\n    URL to more informatoin for the gamescript or the author. The default is ''.</p>\n\n<p><strong>comment</strong> : <em>str, optional</em>;\n    Header block comment to include at the top of info.nut with formatting. The default is ''.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>Writes info.nut</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">outdir</span>,</span><span class=\"param\">\t<span class=\"n\">author</span>,</span><span class=\"param\">\t<span class=\"n\">name</span>,</span><span class=\"param\">\t<span class=\"n\">short_name</span>,</span><span class=\"param\">\t<span class=\"n\">description</span>,</span><span class=\"param\">\t<span class=\"n\">version</span><span class=\"o\">=</span><span class=\"s1\">&#39;SELF_VERSION&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">date</span><span class=\"o\">=</span><span class=\"s1\">&#39;&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">API_version</span><span class=\"o\">=</span><span class=\"s1\">&#39;14&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">url</span><span class=\"o\">=</span><span class=\"s1\">&#39;&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">comment</span><span class=\"o\">=</span><span class=\"s1\">&#39;&#39;</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "otter.otter.build_main", "modulename": "otter.otter.build_main", "kind": "module", "doc": "<p>This script contains the functions needed to build main.nut for the custom map gamescript\nThis is based on boiler plate provided by MinimalGS from Leif Linse.</p>\n\n<p>The boiler plate was editted to include custom functions to for adding towns and industries to user-specified locations.</p>\n\n<p>TODO:\n    - add more options to input data for towns and industry (e.g. dictionary)</p>\n\n<pre><code>- add options to add place labels\n</code></pre>\n"}, {"fullname": "otter.otter.build_main.build_main", "modulename": "otter.otter.build_main", "qualname": "build_main", "kind": "function", "doc": "<p>This function builds main.nut file for a custom map gamescript. </p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p><strong>outdir</strong> : <em>str, path</em>;\n    Output directory to write the main.nut file.</p>\n\n<p><strong>towns_code</strong> : <em>list</em>;\n    A list containing formatted string to add town line code.</p>\n\n<p><strong>industry_code</strong> : <em>list</em>;\n    A list containing formatted string to add industry line code.</p>\n\n<p><strong>canal_code</strong> : <em>list</em>;\n    A list containing formatted string to add canal line code.</p>\n\n<p><strong>signs_code</strong> : <em>list</em>;\n    A list containing formatted string to add signs line code.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>Writes main.nut</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">outdir</span>,</span><span class=\"param\">\t<span class=\"n\">towns_code</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">industry_code</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">canal_code</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">signs_code</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "otter.otter.build_main.build_towns_code", "modulename": "otter.otter.build_main", "qualname": "build_towns_code", "kind": "function", "doc": "<h2 id=\"parameters\">Parameters</h2>\n\n<p>towns : list, dataframe, xlsx, csv\n    A data structure or path to xlsx or csv file containing the information needed to place towns.\n    Each entry must contain: tile X, tile Y, size (small, medium, large), boolean for city, unique name, and target population\ntown_x_header : str, optional\n    Name or index of the town X tile field header in the dataframe, xlsx, or CSV file. The default is 'X'.\ntown_y_header : str, optional\n    Name or index of the town Y tile field header in the dataframe, xlsx, or CSV file. The default is 'Y'.\ntown_size_header : str, optional\n    Name or index of the town size field header in the dataframe, xlsx, or CSV file. The default is 'Size'.\ncity_header : str, optional\n    Name or index of the city flag field header in the dataframe, xlsx, or CSV file. The default is 'City'.\ntown_name_header : str, optional\n    Name or index of the town name field header in the dataframe, xlsx, or CSV file. The default is 'Name'.\ntown_pop_header : str, optional\n    Name or index of the town target population field header in the dataframe, xlsx, or CSV file. The default is 'Population'. If None, this is ignored.\nselect_col : str, optional\n    Name or index of the column to select rows with values from select_val in the dataframe, xlsx, or CSV value. The defualt is None.\nselect_val : str, optional\n    Value to filter the dataframe, xlsx, or CSV value. The default is None.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>List of formatted string to insert into main.nut</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">towns</span>,</span><span class=\"param\">\t<span class=\"n\">town_x_header</span><span class=\"o\">=</span><span class=\"s1\">&#39;X&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">town_y_header</span><span class=\"o\">=</span><span class=\"s1\">&#39;Y&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">town_size_header</span><span class=\"o\">=</span><span class=\"s1\">&#39;Size&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">city_header</span><span class=\"o\">=</span><span class=\"s1\">&#39;City&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">town_name_header</span><span class=\"o\">=</span><span class=\"s1\">&#39;Name&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">town_pop_header</span><span class=\"o\">=</span><span class=\"s1\">&#39;Population&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">select_col</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">select_val</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "otter.otter.build_main.build_industry_code", "modulename": "otter.otter.build_main", "qualname": "build_industry_code", "kind": "function", "doc": "<p>This function helps build the squirrel code function calls for TryIndustry to build industries.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>industry : list, dataframe, xlsx, csv\n    A data structure or path to xlsx or csv file containing the information needed to place towns.\n    Each entry must contain a unique name, X tile, Y tile, type code\nind_x_header : str, optional\n    Name or index of the industry X tile field header in the dataframe, xlsx, or CSV file. The default is 'X'.\nind_y_header : str, optional\n    Name or index of the industry Y tile field header in the dataframe, xlsx, or CSV file. The default is 'Y'.\nind_name_header : str, optional\n    Name or index of the industry name field header in the dataframe, xlsx, or CSV file. The default is 'Name'.\nind_type_header : str, optional\n    Name or index of the industry type field header in the dataframe, xlsx, or CSV file. The default is 'Type'.\ntrylevel_header : str, optional\n    Name or index of the header containing the flag for leveling in the dataframe, xlsx, or CSV file. The defeault is 'Level'.\nlevel_x2_header : str, optional\n    Name or index of the header containing the number of tiles down for leveling in the dataframe, xlsx, or CSV file. The defeault is 'Level'.\nlevel_y2_header : str, optional\n    Name or index of the header containing the number of tiles across for leveling in the dataframe, xlsx, or CSV file. The defeault is 'Level'.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>List of formatted string to insert into main.nut</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">industry</span>,</span><span class=\"param\">\t<span class=\"n\">ind_x_header</span><span class=\"o\">=</span><span class=\"s1\">&#39;X&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">ind_y_header</span><span class=\"o\">=</span><span class=\"s1\">&#39;Y&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">ind_name_header</span><span class=\"o\">=</span><span class=\"s1\">&#39;Name&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">ind_type_header</span><span class=\"o\">=</span><span class=\"s1\">&#39;Type&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">trylevel_header</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">level_x2_header</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">level_y2_header</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "otter.otter.build_main.build_canal_code", "modulename": "otter.otter.build_main", "qualname": "build_canal_code", "kind": "function", "doc": "<p>This function helps build the squierrel code function calls for PlaceCanal to place canal tiles.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>canals : list, dataframe, xslx, csv\n    A data structure or path to xlsx or csv file containing x,y tile coordinates to build canals.\nx_header : str, optional\n    Name or index of the industry X tile field header in the dataframe, xlsx, or CSV file. The default is 'X'.\ny_header : str, optional\n    Name or index of the industry Y tile field header in the dataframe, xlsx, or CSV file. The default is 'Y'.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>List of formatted string to insert into main.nut</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">canals</span>, </span><span class=\"param\"><span class=\"n\">x_header</span><span class=\"o\">=</span><span class=\"s1\">&#39;X&#39;</span>, </span><span class=\"param\"><span class=\"n\">y_header</span><span class=\"o\">=</span><span class=\"s1\">&#39;Y&#39;</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "otter.otter.build_main.build_signs_code", "modulename": "otter.otter.build_main", "qualname": "build_signs_code", "kind": "function", "doc": "<p>This function helps build the squirrel code function calls for PlaceSigns to place signs.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>canals : list, dataframe, xslx, csv\n    A data structure or path to xlsx or csv file containing x,y tile coordinates to build signs.\nx_header : str, optional\n    Name or index of the industry X tile field header in the dataframe, xlsx, or CSV file. The default is 'X'.\ny_header : str, optional\n    Name or index of the industry Y tile field header in the dataframe, xlsx, or CSV file. The default is 'Y'.\nlabel_header : str, optional\n    Name or index of the industry label field header in the dataframe, xlsx, or CSV file. The default is 'label'.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>List of formatted string to insert into main.nut</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">signs</span>, </span><span class=\"param\"><span class=\"n\">x_header</span><span class=\"o\">=</span><span class=\"s1\">&#39;X&#39;</span>, </span><span class=\"param\"><span class=\"n\">y_header</span><span class=\"o\">=</span><span class=\"s1\">&#39;Y&#39;</span>, </span><span class=\"param\"><span class=\"n\">label_header</span><span class=\"o\">=</span><span class=\"s1\">&#39;label&#39;</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "otter.otter.build_version", "modulename": "otter.otter.build_version", "kind": "module", "doc": "<p>This script contains the functions needed to build version.nut for the custom map gamescript\nThis is based on boiler plate provided by MinimalGS from Leif Linse.</p>\n"}, {"fullname": "otter.otter.build_version.build_version", "modulename": "otter.otter.build_version", "qualname": "build_version", "kind": "function", "doc": "<p>This function creates info.nut for a custom map gamescript</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p><strong>outdir</strong> : <em>str, path</em>;\n    Output directory to write the info.nut file.</p>\n\n<p><strong>version</strong> : <em>str</em>;\n    version of the gamescript.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>Writes version.nut</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">outdir</span>, </span><span class=\"param\"><span class=\"n\">version</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "otter.otter.create_random_points", "modulename": "otter.otter.create_random_points", "kind": "module", "doc": "<p>This script contains functions to facilitate the creation of random\npoints given special constraints.\nRandom points can be used to to assign industry locations.</p>\n\n<p>The advantage of these tools is that locations can be contrained to\ncertain zones meeting defined conditions.</p>\n\n<p>This is an advanced tool requiring knowledge of GIS.</p>\n\n<p>These tools are designed to be used with the georeference png output\nfrom bother.</p>\n"}, {"fullname": "otter.otter.create_random_points.create_random_points", "modulename": "otter.otter.create_random_points", "qualname": "create_random_points", "kind": "function", "doc": "<p>This function creates random points given zonal and value constraints and returns the\nrandom lat-long and map row,col index. Use a dict if defining different inputs for \nmultiple zones. If a single value is passed, the input will apply to all zones.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>ras : str, path\n    path to a raster from georeferenced png output from bother.\nzone_shp_path : str, path, optional\n    path to shapefile containing zones. The default is None.\nzone_col : str, optional\n    name of the attribute field defining zones. The default is None.\nmethod : dict\n    dictionary defining random points generation methods where the zone id is the key\noutpath : str, path, optional\n    path to the output CSV or Excel file or shapefile to write the output dataframe. The default is None.\nsize : int, tuple, dict\n    number of points to generate; must pass a dict if defining different inputs for multiple zones\nintensity : float, dict\n    used for poisson or cluster poisson; must pass a dict if defining different inputs for multiple zones\ncenter : iter of shape (2,), dict\n    a point where simulations will be centered for normal; must pass a dict if defining inputs for multiple zones\ncov : float, array, dict\n    std. dev. or 2x2 cov matrix for normal or cluster normal; must pass a dict if defining inputs for multiple zones\nn_seeds : int, dict\n    number of sub-clusters to use; must pass a dict if defining inputs for multiple zones\ncluster_radius : float, iter, dict\n    radius of each cluster; must pass a dict if defining inputs for multiple zones</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>DataFrame of random points.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">ras</span>,</span><span class=\"param\">\t<span class=\"n\">zone_shp_path</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">zone_col</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">method</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">outpath</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">size</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">intensity</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">center</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">cov</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">n_seeds</span><span class=\"o\">=</span><span class=\"mi\">2</span>,</span><span class=\"param\">\t<span class=\"n\">cluster_radius</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "otter.otter.georef_png", "modulename": "otter.otter.georef_png", "kind": "module", "doc": "<p>This script contains a function to automatically georeference the png output from bother\nback to a tif using the tif output from bother as a template for georeferencing.</p>\n"}, {"fullname": "otter.otter.georef_png.georef_png", "modulename": "otter.otter.georef_png", "qualname": "georef_png", "kind": "function", "doc": "<p>Georefenece the png output from bother and convert to tif for editing.\nThe resulting tif can be used used to extract game-grid row,col indices for towns and industry.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p><strong>bother_tif</strong> : <em>str, path</em>;\n    path to the original tif output from bother.</p>\n\n<p><strong>bother_png</strong> : <em>str, path</em>;\n    path to the original png output from bother.</p>\n\n<p><strong>png_scale</strong> : <em>str</em>;\n    scale used to create the png in bother. 'widthxheight'</p>\n\n<p><strong>new_tif</strong> : <em>str, path</em>;\n    file path to new tif to write or overwrite.</p>\n\n<p><strong>crs</strong> : <em>str, optional</em>;\n    coordinate reference system by EPSG code. The default is 'epsg:4326'.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>Writes GeoTIFF.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">bother_tif</span>, </span><span class=\"param\"><span class=\"n\">bother_png</span>, </span><span class=\"param\"><span class=\"n\">png_scale</span>, </span><span class=\"param\"><span class=\"n\">new_tif</span>, </span><span class=\"param\"><span class=\"n\">crs</span><span class=\"o\">=</span><span class=\"s1\">&#39;epsg:4326&#39;</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "otter.otter.get_latlong_from_map", "modulename": "otter.otter.get_latlong_from_map", "kind": "module", "doc": "<p>This script contains a function to convert row,col indices from a scaled map to\nreal-world latitude and longitude.</p>\n\n<p>Example use case:\n    - Record the row,col of manually placed features in Scenario Building\n      and use this function to convert those coordinates to real-world\n      lat-long and shapefile that can be added to a GIS map for viewing</p>\n"}, {"fullname": "otter.otter.get_latlong_from_map.get_latlong_from_map", "modulename": "otter.otter.get_latlong_from_map", "qualname": "get_latlong_from_map", "kind": "function", "doc": "<p>This function finds lat,long coords given row,col grid indices from a OTTD map.\nLongitude is the X coordinate (column)\nLatitude is the Y coordinate (row)</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p><strong>ras</strong> : <em>str, path</em>;\n    path to a raster created from georeferencing the png output of bother.</p>\n\n<p><strong>grid_coords</strong> : <em>str, dataframe, geodataframe, list</em>\n    Path to a shapefile, CSV, or excel file or a dataframe or geodataframe or a list of row,col pairs</p>\n\n<p><strong>outpath</strong> : <em>str, path</em>;\n    path to an ouput csv or excel file or shapefile to write the lat,long coords</p>\n\n<p><strong>row_col</strong> : <em>str, optional</em>;\n    name of the column containing the row value. The default is None.</p>\n\n<p><strong>col_col</strong> : <em>str, optional</em>;\n    name of the column containing the column value. The default is None.</p>\n\n<p><strong>select_col</strong> : <em>str</em>;\n    column name to filter values</p>\n\n<p><strong>select_val</strong> : <em>str, int, float</em>;\n    value used to fitler values in select_col</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>Dataframe with long,lat coordinates.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">ras</span>,</span><span class=\"param\">\t<span class=\"n\">grid_coords</span>,</span><span class=\"param\">\t<span class=\"n\">outpath</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">row_col</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">col_col</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">select_col</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">select_val</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "otter.otter.get_map_coords", "modulename": "otter.otter.get_map_coords", "kind": "module", "doc": "<p>This script contains a function to extract the row,col indices from a scaled map.\nThis function can be used to find the row,col indices on the game map for towns\nand industries using real-world coordinates.</p>\n\n<p>The OTTD grid coordinate system has the same origin as numpy data arrays\nwhere the top left is 0,0. Therefore, raster array rows coorespond with\nOTTD X coordinates and columns correspond with OTTD Y coordinates (clockwise orientation)</p>\n"}, {"fullname": "otter.otter.get_map_coords.get_map_coords", "modulename": "otter.otter.get_map_coords", "qualname": "get_map_coords", "kind": "function", "doc": "<p>This function finds row,col indicies (clockwise) of OTTD maps from given lat-long coordinates.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p><strong>ras</strong> : <em>str, path</em>;\n    path to a raster created from georeferencing the png output of bother.</p>\n\n<p><strong>coords</strong> : <em>str, dataframe, geodataframe, list</em>\n    Path to a shapefile, CSV, or excel file or a dataframe or geodataframe or a list of longtitude-latitude pairs</p>\n\n<p><strong>outpath</strong> : <em>str, path</em>;\n    path to an ouput csv or excel file to write the row,col indices to</p>\n\n<p><strong>lat_col</strong> : <em>str, optional</em>;\n    name of the column containing the latitude. The default is None.</p>\n\n<p><strong>long_col</strong> : <em>str, optional</em>;\n    name of the column containing the longitude. The default is None.</p>\n\n<p><strong>select_col</strong> : <em>str</em>;\n    column name to filter values</p>\n\n<p><strong>select_val</strong> : <em>str, int, float</em>;\n    value used to fitler values in select_col</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>Dataframe with game-grid row,col indices (clockwise)</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">ras</span>,</span><span class=\"param\">\t<span class=\"n\">coords</span>,</span><span class=\"param\">\t<span class=\"n\">outpath</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">lat_col</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">long_col</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">select_col</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">select_val</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "otter.otter.town_data_to_json", "modulename": "otter.otter.town_data_to_json", "kind": "module", "doc": "<p>This script contains a function to convert a simple pandas dataframe\nto a .json file that can imported in the Scenario Builder to import\ntown data.</p>\n\n<p>Rows coorespond with OTTD X coordinates (height) (clockwise orientation)\nColumns correspond with OTTD Y coordinates (width) (clockwise orientation)</p>\n"}, {"fullname": "otter.otter.town_data_to_json.town_data_to_json", "modulename": "otter.otter.town_data_to_json", "qualname": "town_data_to_json", "kind": "function", "doc": "<p>This function converts town data from an input data format (e.g. pandas dataframe)\nto a .json file that can be used to import into the Scenario Builder.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p><strong>town_data</strong> : <em>str, path, dataframe</em>;\n    table of town data as a path to a shapefile, CSV, excel file or a pandas dataframe or geodataframe.</p>\n\n<p><strong>map_width</strong> : <em>str, int</em>;\n    width of the intended map to convert coordinates. OTTD maps are described as width x height.</p>\n\n<p><strong>map_height</strong> : <em>str, int</em>;\n    height of the inteded map to convert coordinates. OTTD maps are described as width x height.</p>\n\n<p><strong>json_outfile</strong> : <em>str, path</em>;\n    name and path to the output .json file with .json extension</p>\n\n<p><strong>name_field</strong> : <em>str, optional</em>;\n    name of the column defining the name of the town. The default is 'name'.</p>\n\n<p><strong>pop_field</strong> : <em>str, optional</em>;\n    name of the column defining the population. The default is 'population'.</p>\n\n<p><strong>city_field</strong> : <em>str, optional</em>;\n    name of the column defining the true/false flag for cities . The default is 'city'.</p>\n\n<p><strong>x_field</strong> : <em>str, optional</em>;\n    name of the column defining the x coordinate (height). The default is 'row'.</p>\n\n<p><strong>y_field</strong> : <em>str, optional</em>;\n    name of the column defining the y coordinate (width). The default is 'col'.</p>\n\n<p><strong>select_col</strong> : <em>str</em>;\n    column name to filter values</p>\n\n<p><strong>select_val</strong> : <em>str, int, float</em>;\n    value used to fitler values in select_col</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>Writes a .json file.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">town_data</span>,</span><span class=\"param\">\t<span class=\"n\">map_width</span>,</span><span class=\"param\">\t<span class=\"n\">map_height</span>,</span><span class=\"param\">\t<span class=\"n\">json_outfile</span>,</span><span class=\"param\">\t<span class=\"n\">name_field</span><span class=\"o\">=</span><span class=\"s1\">&#39;name&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">pop_field</span><span class=\"o\">=</span><span class=\"s1\">&#39;population&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">city_field</span><span class=\"o\">=</span><span class=\"s1\">&#39;city&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">x_field</span><span class=\"o\">=</span><span class=\"s1\">&#39;row&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">y_field</span><span class=\"o\">=</span><span class=\"s1\">&#39;col&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">select_col</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">select_val</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}];

    // mirrored in build-search-index.js (part 1)
    // Also split on html tags. this is a cheap heuristic, but good enough.
    elasticlunr.tokenizer.setSeperator(/[\s\-.;&_'"=,()]+|<[^>]*>/);

    let searchIndex;
    if (docs._isPrebuiltIndex) {
        console.info("using precompiled search index");
        searchIndex = elasticlunr.Index.load(docs);
    } else {
        console.time("building search index");
        // mirrored in build-search-index.js (part 2)
        searchIndex = elasticlunr(function () {
            this.pipeline.remove(elasticlunr.stemmer);
            this.pipeline.remove(elasticlunr.stopWordFilter);
            this.addField("qualname");
            this.addField("fullname");
            this.addField("annotation");
            this.addField("default_value");
            this.addField("signature");
            this.addField("bases");
            this.addField("doc");
            this.setRef("fullname");
        });
        for (let doc of docs) {
            searchIndex.addDoc(doc);
        }
        console.timeEnd("building search index");
    }

    return (term) => searchIndex.search(term, {
        fields: {
            qualname: {boost: 4},
            fullname: {boost: 2},
            annotation: {boost: 2},
            default_value: {boost: 2},
            signature: {boost: 2},
            bases: {boost: 2},
            doc: {boost: 1},
        },
        expand: true
    });
})();